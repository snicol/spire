= spire

Light controller-only rack framework with a dash of views.

= Installation

    gem install spire
    spire -c project_name
    cd !$ && rackup

This will install spire, create a project called 'project_name' in the same directory it's run in, and then start the site. 

= Usage 

== Routes

Routes are used in the config.ru, they work like the old-style Rails routes:
    run Spire::Router.new(path, {
      "default" => "index#index", # the default route!
      "/index" => "index#index",
    })
The "default" route is what is opened when someone goes to '/' on your address.
    "/index" => "index#index",
This would match the '/index' request to the IndexController (in app/controllers) and execute the index method in that controller.
    "/foo/bar" => "foo#bar"
That would when '/foo/bar' is requested return the response found in the FooController and the value in Bar that's returned.

== Controllers

Controllers are named to tie with the routes (read above). They are stored in:
    project_name/app/controllers/
With the naming scheme like so:
		FooController.rb
Where Foo is the name of the controller. The name must be camel-cased. All classes must be defined like so:
    class Foo < Spire::MainController

    end
as a skeleton controller for the framework to use. An example response would look like this:
    class Index < Spire::MainController
      def index
        "This is just a response"
      end
    end
This would display a html page with that text. The Response.new initiator could be used like so:
    def index
			@status = 200
			@content_type = "text/html;"
			return "Hi, I'm a test page!"
		end
Where the first instance variable @status is the HTTP status to show, the second being the content type, and the last being the returned value as a string.

== Views

=== RHTML
RHTML templates are executed using erubis due to its speed. To create a erb view, you must create a view in:
		/app/views/
With the naming scheme of:
		template.rhtml
The .rhtml is important so Spire knows what file it is. To pass data to a view, you simply define an instance variable before you render the template and it will automatically be accessible in your view template.
To render a template, you simply use:
		render("index.rhtml")

=== HAML
HAML templates can be rendered like so:
    render("index.haml")
This would load the index.haml view in:
    /app/views/index.haml
To pass data to the view, define and fill an instance variable with content or an object, and you can use it inside your HAML view.

=== HTML
HTML are static templates to be used in your project/app, they can't use variables, nor can they execute ruby code. They can be rendered using:
    render("index.html")
Which would load the 'index.html' file from:
    project_name/app/views/index.html
The first argument is the file name, the second being the extension.